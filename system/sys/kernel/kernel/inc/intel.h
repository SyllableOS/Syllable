
/*
 *  The AtheOS kernel
 *  Copyright (C) 1999 - 2000 Kurt Skauen
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of version 2 of the GNU Library
 *  General Public License as published by the Free Software
 *  Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#ifndef	EXEC_INTEL_H
#define	EXEC_INTEL_H

#ifdef __cplusplus
extern "C"
{
#endif
#if 0
}				/* Make Emacs auto-indent work */
#endif

#include <atheos/types.h>

#define	EFLG_CARRY			0x00000001
#define	EFLG_PARITY			0x00000004
#define	EFLG_AUX_CARRY	0x00000010
#define	EFLG_ZERO	0x00000040
#define	EFLG_SIGN	0x00000080
#define	EFLG_TRAP	0x00000100	/* Trap (Single step)           */
#define	EFLG_IF		0x00000200	/* Interrupt enable             */
#define	EFLG_DF		0x00000400	/* Direction (String ops.)      */
#define	EFLG_OF		0x00000800	/* Overflow                     */
#define	EFLG_IOPL	0x00003000	/* I/O Privilege level          */
#define	EFLG_NT		0x00004000	/* Nested task                  */
#define	EFLG_RESUME	0x00010000
#define	EFLG_VM		0x00020000	/* Virtual 86 mode              */
#define EFLG_AC		0x00040000
#define EFLG_VIF	0x00080000	/* Virtual interrupt flag       */
#define EFLG_VIP	0x00100000	/* Virtual interrupt pending    */
#define EFLG_ID		0x00200000

/*
 * Return values for the 'vm86()' system call
 */

#ifdef __KERNEL__

  /* The four data and code selectors used in AtheOS */
#define CS_KERNEL	0x08	/* Kernel (Ring 0) code segment */
#define CS_USER		0x13	/* User (Ring 3) code segment */
#define DS_KERNEL	0x18	/* Kernel (Ring 0) data segment */
#define DS_USER		0x23	/* User (Ring 3) data segment */

#define VM86_TYPE(retval)	((retval) & 0xff)
#define VM86_ARG(retval)	((retval) >> 8)

#define VM86_SIGNAL	0	/* return due to signal */
#define VM86_UNKNOWN	1	/* unhandled GP fault - IO-instruction or similar */
#define VM86_INTx	2	/* int3/int x instruction (ARG = x) */
#define VM86_STI	3	/* sti/popf/iret instruction enabled virtual interrupts */

/**** END OF VM86 STUFF ***************************************/


typedef struct i3Task
{
	uint16 previous;
	uint16 r1;
	uint32 *esp0;
	uint16 ss0;
	uint16 r2;
	uint32 *esp1;
	uint16 ss1;
	uint16 r3;
	uint32 *esp2;
	uint16 ss2;
	uint16 r4;
	uint32 *cr3;
	void *eip;
	uint32 eflags;
	uint32 eax;
	uint32 ecx;
	uint32 edx;
	uint32 ebx;
	uint32 *esp;
	uint32 ebp;
	uint32 esi;
	uint32 edi;
	uint16 es;
	uint16 r5;
	uint16 cs;
	uint16 r6;
	uint16 ss;
	uint16 r7;
	uint16 ds;
	uint16 r8;
	uint16 fs;
	uint16 r9;
	uint16 gs;
	uint16 r10;
	uint16 ldt;
	uint16 r11;
	uint16 ctrl;
	uint16 IOMapBase;
	uint8 IOMap[8192];
} TaskStateSeg_s;


typedef struct i3DescrTable
{
	uint16 Limit __attribute__ ( ( packed ) );
	uint32 Base __attribute__ ( ( packed ) );
} DescriptorTable_s;

struct i3IntrGate
{
	uint16 igt_offl;	/* 0-15 of base         */
	uint16 igt_sel;		/* selector                             */
	uint16 igt_ctrl;	/* P/DPL                                        */
	uint16 igt_offh;	/* 16-31 of base        */
};

struct i3Desc
{
	uint16 desc_lml;	/* limit 0-15           */
	uint16 desc_bsl;	/* base 0-15            */
	uint8 desc_bsm;		/* base 16-23           */
	uint8 desc_acc;		/* type/dpl/p           */
	uint8 desc_lmh;		/* limit 16-19  */
	uint8 desc_bsh;		/* base 24-31           */
};

#define	PTE_PRESENT	0x001	/* dir/page is present/valid                    */
#define	PTE_WRITE	0x002	/* dir/page is writeable                        */
#define	PTE_USER	0x004	/* only accessible by supervisor                */
#define	PTE_ACCESSED	0x020	/* the page has been accessed (R or W)          */
#define	PTE_DIRTY	0x040	/* the page has been written to                 */
#define	PTE_AVAILABLE	0xE00	/* free for system use (NOT APPLICATIONS)       */

	/*
	 *      Bit definitions in the exception error code generated by a page fault
	 */

#define	PFE_PROTVIOL	0x0001	/* if set, the page-fault was caused by a protection
				 * violation, othervise by a not present page
				 */
#define	PFE_WRITE	0x0002	/* if set fault caused by a write, othervise by a read  */
#define	PFE_USER	0x0004	/* if set fault caused in user-mode othervise in supervisor-mode */

/*
 *	PTE_ALLOCATED flag have different meanings in directory and page tables.
 *	When set in a directory table it means that there is allocated memory for
 *	this page table. For a page table entry it is indicates that the entry is
 *	in use.
 */

/* #define	PTE_ALLOCATED		0x400	*/

/*void	sys_FlushCaches( void );*/


void set_page_directory_base_reg( void *pPageTable );
void *get_page_directory_base_reg( void );

void load_fpu_state( void *pState );
void save_fpu_state( void *pState );



void GetIDT( DescriptorTable_s * psTable );
void SetIDT( DescriptorTable_s * psTable );
void GetGDT( DescriptorTable_s * psTable );
void SetGDT( DescriptorTable_s * psTable );

void SetTR( int nTaskReg );

void SetupDataSelectors( void );
void enable_mmu( void );

void InitIDT( void );
bool Desc_SetBase( uint16 desc, uint32 base );
uint32 Desc_GetBase( uint16 desc );
bool Desc_SetLimit( uint16 desc, uint32 limit );
uint32 Desc_GetLimit( uint16 desc );
bool Desc_SetAccess( uint16 desc, uint8 acc );
uint8 Desc_GetAccess( uint16 desc );
uint16 Desc_Alloc( int32 table );
void Desc_Free( uint16 desc );
#endif /* __KERNEL__ */


static inline uint64 read_pentium_clock( void )
{
	register uint32 nLow;
	register uint32 nHigh;

	__asm__ __volatile__( "rdtsc":"=a"( nLow ), "=d"( nHigh ) );

	return ( ( ( uint64 )nHigh ) << 32 | nLow );
}

#ifdef __cplusplus
}
#endif

#endif /*       EXEC_INTEL_H    */
